<< spring boot >>

    * maven : 라이브러리 관리
        => repository : 라이브러리 모음
    * boolean 값이 없는 곳 에서 true/false
        0 : false
        0 제외 : true

    - 프로젝트 구조
        repository => (entity) => service => (DTO) => controller

    - 서버단 작성
        1) spring framework : 웹개발시 주로 사용
            => 설정 작업할게 많음
        2) spring boot : spring framework 간편화 버전

        * log.info("{} {}") => {} : printf 와 같은 개념 => 자리만 잡아놓는다
        * 동일한 주소(경로), 방식일 때 서버는 다운당함 => 터미널창 확인 => Caused by: java.lang.IllegalStateException: Ambiguous mapping.
            => 위의 경우가 있는지 확인 

    - 프로젝트 생성 (프로그램)
        1. 빌드 툴 설정
            * build : 프로젝트 생성, 라이브러리 설정, 코드작업, 컴파일, 테스트, 패키지작성, 배포 등을 도와주는 작업
            1) gradle : 
                => 일반 text 기반 작성
                => 후발주자(maven 개선형태)
            2) maven
                => xml(html태그 but. 우리가 모르는 태그 why? => 만들어서 사용) 기반 작성
                    * modelmapper : dto ==> Entity / Entity ==> dto 자동으로 처리
                        => 별도의 환경설정 필요
                            1. RootConfig.java 작성
                                참고 : jpa/config
                                * Bean : 스프링부트가 가지고 있고 관리해줘
                        
                        - 사용법
                            modelMapper.map(원본, 수정(ex. MemoDTO.class))

        2. spring boot version 설정
            => 3.4.4 선택

        3. 언어 선택
            => java 선택

        4. 패키지명 : (자유롭게 지정 가능)
            => com.example.demo
            => 기본적으로 3개 정도는 사용해야 함

        5. packaging type 선택
            1) .jar : java 압축 파일
            2) .war : java web 압축 푸일
                => 화면단에 jsp 사용할 경우 사용

        6. java version 선택
            => 부트번전에 따라 선택이 달라질 수 있음

        7. 필요 라이브러리 선택
            => 선택시 해당 엔진으로 시작
            1) Spring Web
            2) dev tools
            3) thymeleaf
            4) lombok
                => 여기까지가 demo 에서 사용
            => jpa 부터 사용하게 되는 라이브러리
                => home 화면을 띄우기 위해서는 application.properties 진입
                    1. thymeleaf 결과 보관하지 않기
                        spring.thymeleaf.cache=false
                    2. db 설정
                    3. SQL 구문 실행
                    4. 콘솔창에 출력되는 쿼리를 가독성이 좋게 포맷팅
                    5. 로그 자세히 
                    6. ? 바인딩 자세히
            5) spring data jpa
            6) oracle driver
            7) validation
            - 별도 추가
                => maven properties 에서 해당 코드 복사후 porm.xml dependencies 에 추가
                1) thymeleaf layout dialect
                    <dependency>
                        <groupId>nz.net.ultraq.thymeleaf</groupId>
                        <artifactId>thymeleaf-layout-dialect</artifactId>
                        <version>3.4.0</version>
                    </dependency>

                2) modelMapper
                    <dependency>
                        <groupId>org.modelmapper</groupId>
                        <artifactId>modelmapper</artifactId>
                        <version>3.2.2</version>
		            </dependency>

                3) querydsl-jpa
                    <dependency>
                        <groupId>com.querydsl</groupId>
                        <artifactId>querydsl-jpa</artifactId>
                        <version>5.1.0</version>
                        <classifier>jakarta</classifier>
                    </dependency>

                4) querydsl-apt
                    <dependency>
                        <groupId>com.querydsl</groupId>
                        <artifactId>querydsl-apt</artifactId>
                        <version>5.1.0</version>
                        <classifier>jakarta</classifier>
                    </dependency>

                5) apt-maven-plugin
                    <plugin>
                        <groupId>com.mysema.maven</groupId>
                        <artifactId>apt-maven-plugin</artifactId>
                        <version>1.1.3</version>
                        <executions>
                            <execution>
                                <goals>
                                <goal>process</goal>
                                </goals>
                                <configuration>
                                <outputDirectory>target/generated-sources/annotations</outputDirectory>
                                <processor>com.querydsl.apt.jpa.JPAAnnotationProcessor</processor>
                                </configuration>
                            </execution>
                        </executions>
                        </plugin>
        8. config 파일 src.main.java.com.example.프로젝트명 => 폴더째로 붙여넣기

        9. BaseEntity 작성
                main/Application 에 @EnableJpaAuditing 추가

    - 데이터베이스(DB) 작업

        - 테스트 (CRUD) = Repository + Entity 확인
            => 단위 테스트(메서드별) 실행 (중간중간 이상이 없는지 실행해서 테스트)
            * main 폴더 안에다가 작성 => 테스트의 목적일 때만 test 폴더 사용
            * @Test => Junit 라이브러리 안에 있음

            - 형식
                테스트 폴더의 jpa 에서 실행
                1. @SpringBootTest 선언 : 테스트용 클래스임을 선언함
                2. 테스트할 객체 + @Autowired 선언
                    * @Autowired == new 클래스명
                3. @Test 어노테이션 선언 후 메서드 작성
                    => 리턴타입이 무조건 void 여야 함

            - CRUD
                C(Insert) : save(Entity) : insert
                R(Read)
                U(Update) : save(Entity) : update
                    findById(1L) : select * from 테이블명 where id = 1
                        => 원본 찾기
                    set컬럼명()
                        => 전체 set 불러와서 위의 원본과 대조해서 바뀐 부분을 감지
                            => 특정부분이 아닌 전체를 감지한다!
                D(Delete)

                - C 와 U 구분
                    둘다 save() 호출
                    => 원본과 바뀐 부분이 있다면 변경
            
        - 메서드 (Repository)
            * Jpa 에서 제공하는 메서드 외는 쿼리 메서드를 사용해서 추출
            1) save() : insert, update
            2) findById() : select(where절 가짐)
                => @Id 어노테이션이 부여된 요소(PK)를 기준으로 찾기
                    * Id : Id 어노테이션이 붙은것을 의미
            3) findAll() : 전체조회
                => select 8 from 테이블명
               findALL(Pageable) : 페이지로 나누어서 조회
               => Entity 형식으로 추출
                => Pageable pageable = PageRequest.of(pageNumber, pageSize, Sort.by("컬럼명").descending()); => 선언 해야함
                    => pageNumber : 몇페이지를 가지고 나오는지
                    => pageSize : 한페이지에 몇개의 결과를 조회할 건지
                    => descending : 내림차순
            4) delete()
                deleteById()
                => 삭제
        
        - 프레임워크
            1. MyBatis

            2. JPA(Java Persistence API) : 객체 == 테이블 : 객체를 테이블로 매핑
                참고 : application.properties, entity/Student
                => SQL 거의 안보임 -> 모든걸 메서드로 처리
                => JPA 기술을 구현한 Hibernate 구현체가 존재
                => 어떤 DB를 사용하던 구현해주는 툴
                
                * @Entity : DB table 과 동일해짐
                * java 와 DB 의 변수명 규칙
                    => java 에서는 대/소문자 구별
                    => DB 는 대/소문자 구별 X
                        => java 의 대문자는 앞에 _ 를 붙여서 DB 이름으로 변환
                
                - db 설정
                    * DDL : create, alter, drop

                    1. db 환경설정
                        spring.datasource.driver-class-name=oracle.jdbc.OracleDriver
                        spring.datasource.url=jdbc:oracle:thin:@localhost:1521:xe
                        spring.datasource.username=오라클username
                        spring.datasource.password=비밀번호
                    3. SQL 구문 실행
                        spring.jpa.hibernate.ddl-auto=create
                    4. 콘솔창에 출력되는 쿼리를 가독성이 좋게 포맷팅
                        spring.jpa.properties.hibernate.format_sql=true
                        spring.jpa.properties.hibernate.highlight_sql=true

                    5. 로그 자세히 
                        logging.level.org.hibernate.SQL=debug

                    6. ? 바인딩 자세히
                        logging.level.org.hibernate.orm.jdbc.bind=trace
                    
                    - 데이터베이스 초기화 전략
                        - spring.jpa.hibernate.ddl-auto= 5가지 종류
                        1. create : 기존 테이블 삭제 후 테이블 생성 (개발시)
                            => 테이블명 : Entity 명이 기본
                        2. create-drop : 기존 테이블 삭제 후 테이블 생성 / 종료시점에 테이블 삭제 (개발시)
                        3. update : 변경된 부분만 적용 (개발시)
                        4. validate : 엔티티와 테이블 정상 매핑 확인
                            => 연결만 하는 코드
                        5. none : 사용하지 않음
                            4, 5. => 스테이징, 운영환경
                    
                    - 어노테이션
                        참고 : entity/student
                        @Table(name = "다른name") : Entity 명이 아닌 지정된 이름으로 테이블 생성
                        
                        @Id(선언한 변수명) : primary key, not null 적용
                        
                        @GeneratedValue : 시퀀스 생성
                            * 오라클DB 인 경우에 적용됨, 다른 DB는 다름
                            => create sequence studenttbl_seq start with 1 increment by 50 => 1, 51, 순으로 50씩 증가함
                            @GeneratedValue(strategy = GenerationType.5가지(3가지만 알면 됨))
                                1. AUTO : 50씩 증가
                                2. IDENTITY : 1씩 증가
                                    => generated by default as identity
                                3. SEQUENCE : 혼자서 사용 X
                                    + SequenceGenerator(name = "이름", sequenceName = "시퀀스명", allocationSize = 증가수치)
                        
                        @Column() : 컬럼과 관련된 기능
                            1. name = "새로운name" : 컬럼의 이름을 바꿀수 있음, 
                            2. length = 길이 : 길이 지정 가능
                            3. nullable = false : not null
                            4. unique = true : unique키 지정
                            5. columnDefinition = "" : 컬럼에 대한 정의 가능
                                => check 제약 조건 : columnDefinition = "CONSTRAINT chk_gender CHECK (gender IN ('M', 'F'))"
                                    * 이름을 안주려면 : CHECK (gender IN ('M', 'F') 만 작성
                                ex) @Column(name = "sname", columnDefinition = "varchar2(20) not null unique")
                        
                        - 날짜 어노테이션
                            참고 : StudentRepository(Test), entity/student
                            
                            - org.hibernate 에서 제공
                                @CreationTimestamp : 데이터 삽입시, 자동으로 현재 시스템 날짜 시간 삽입
                                    => insert 구문이 아님
                                @UpdateTimestamp : 데이터 삽입 + 수정시 자동으로 현재 시스템 날짜 시간 삽입
                                    - 공통점 : 시간을 넣어줌
                                    - 차이점 : cDateTime = insert 할 때만 (처음 생성시간 고정)
                                              uDateTime = insert + 데이터 수정 할 때마다 변경된
                            - org.springframework 에서 제공 
                                => org.hibernate 와 똑같은 기능 + 설정작업 필요
                                    설정작업 : main 이 있는 클래스(jpaApplication)에 @EnableJpaAuditing 추가
                                                => Entity 클래스에 @EntityListeners(value = AuditingEntityListener.class) 추가
                                => 복잡한 작업이나 더 많이 쓰임 why? 상속 작업을 위해서
                                @CreatedDate
                                @LastModifiedDate

                                * @MappedSuperclass
                                    => 테이블과 연동(매핑)되지 않고 자식 클래스에 Entity의 매핑 정보 상속

                        @Enumerated(EnumType.타입)
                            => 정해진 것들만 받아들이기 위해 사용
                            1. enum 정의
                                public enum Grade {
                                    FRESHMAN, SOPHOMORE, JUNIOR, SENIOR
                                }
                            2. @Enumerated(EnumType.STRING)
                                @Column(nullable = false, length = 20)
                                private Grade grade;
                            3. insert or update 실행

                    - 타입에 따른 default 자리수
                        String : 255자리
                        long : 19자리
                        int : 10자리
                            => 자동으로 not null 처리
                        LocalDateTime : timestamp 타입의 6자리로 생성
                        
    - 화면(front)단 작성
        => html + css + javascript + java
        
        1) jsp 활용 : html 코드 + java 코드 동시 작성
            * .jsp
            => spring boot 에서 사용하기 위해서는 설정 작업이 별도로 필요
        2) 특정 템플릿 엔진 활용
            * .html
            1. thymeleaf 사용
            2. mustache
            3. groovy
            4. freemaker
            5. velocity

        - 수정 작업 단계
            참고 : jpa/memo
            1) 보여주기
                ex) /memo/update?mno=3 + get
            2) 실제 수정
                ex) /memo/update?mno=3 + post
    
    - spring 주요 개념
        참고 : controller.HomeController.java
        1) IoC (Inversion of Control) : 메서드나 객체의 호출 작업을 개발자가 결정하는 것이 아니라, 외부(스프링 컨테이너)에서 결정 (제어의 역전)

            * 기존 java 에서는 new 안하면 nullPointerException 이 나오나 spring boot 에서는 Exception 이 안남!
                => IoC + Injection 의 만남으로 가능! => spring 컨테이너의 주요 개념

            ex) 일반적인 방법 : class A {} 를 class B {} 에서의 사용
                            => class B {
                                A obj = new A(); 객체 생성 }

                => 제어의 역전 : 단, 알려는 줘야 함
                    => 컨테이너는 어느 객체를 생성할 것인지 알아야 함 => 어노테이션(@) 사용해서 알려주기
                        * 컨테이너가 생성한 객체 : bean
                        * 싱글톤 방식(객체는 하나만 생성)으로 객체 생성
                            1) @Controller
                            2) @Service
                            3) @Component
        
            * run 을 해서 띄운 포트에 또하나의 run 을 할 수 없음

        2) Injection(주입)
            @Controller, @Service, @Component 을 통해서 생성된 객체를 언제, 어디에 사용할 것인지 알려주는 개념
            
            - 주입 시기를 알려주는 어노테이션
                @Autowired => 필요한 객체 위에 작성
                    => 컨테이너가 관리하는 객체를 주입해주세요의 의미
                    => @Service 가 붙은 객체를 new 의 개념으로 가지고 있음
                    => nullPointerException 안나게 해줌

                    @Autowired                            == 클래스에 @RequiredArgsConstructor
                    private MemoRepository memoRepository == private final MemoService memoService
                    * 테스트 클래스에서는 final 과 @RequiredArgsConstructor 사용 못함

        3) 경로 임의로 생성
            ex) http://localhost:8080/ ==> Controller 파일의 메서드와 매핑
            * getMapping("/") => / 는 8080의미
                => 포트번호 변경 : application.properties 에서 server.port=바꾸고 싶은 번호

            1. uri 설계
                ex) 게시판 개발
                    게시글 작성 : /board/create
                    게시글 목록 : /board/list
                    게시글 조회 : /board/read
                    게시글 수정 : /board/update
                    * return 해당 파일 위치 정확히 잡아줘야 함!

            - Controller 생성

                - 어노테이션 생성
                    -기본
                        1. @Controller : new Controller 의 개념
                            => 동기식 : 데이터/페이지 같이 만들어서 클라이언트한테 보내는 방식
                        2. @Log4j2 : log 확인
                        3. @RequestMapping("중복되는 값")
                            => @GetMapping() 의 리턴타입을 Stirng -> void로 변경

                            ex)
                            @RequestMapping("중복되는 값")
                            public class BoardController {
                                ex1-1)
                                @GetMapping("/create")
                                public String method() {
                                    return "info";
                                }


                                ex1-2)
                                @GetMapping("/update")
                                public void method() {
                                }
                            }
                                ex1-1) 경로 (String)
                                => http://loacalhost:8080/board/create
                                    => 브라우저요청 => 컨트롤러 응답 => templates 찾기(경로 : templates/return 값 찾기(info))
                                    => templates/info.html 작성
                                
                                ex1-2) 경로 (void)
                                => http://loacalhost:8080/board/update
                                    => 브라우저요청 => 컨트롤러 응답 => templates 찾기(경로 : templates/board/update)
                                    => templates/board/update 작성

                                - 요청 경로 설정
                                    1) void : 같은 페이지에서 결과값을 도출하면 void로 해도 상관 없음
                                    2) String : 같은 페이지가 아닌 다른 페이지에 결과값을 도출하기 원하면 String 으로 해서 return 페이지를 띄워야 함
                    
                    - 번외
                        참고 : rest, frontend/htmlsource/js

                        @RestController : templates 의 html 을 찾지 않고 return 값을 찍어줌
                            => 비동기식 : 데이터만 클라이언트한테 보내주는 방식 (ajax 와 함께 참고 : frontend/js)
                            => 참고로 우리는 json 을 활용해서 함
                            => 화면까지 만들어주는게 아닌 데이터만 뿌려주는 역할 (영화진흥위원회 API 같은 것을 만드는 것)

                            - 매핑 방식
                                참고 : frontend/js/memo
                                1. @GetMapping : read
                                2. @PostMapping : create
                                3. @Put/PatchMapping : update
                                4. @DeleteMapping : delete
                            
                            - 어노테이션
                                @RequestBody : 넘어오는 데이터를 json => 자바 객체 연동
                                @ResponseBody : 데이터만 내보내기
                                    => 컨트롤러에서 리턴하는 값은 데이터 라는 의미
                                    => 템플릿을 찾지 말라는 어노테이션
                                @PathVariable : 뒤에 오는 변수가 주소줄의 경로에 맞춰서 갈때 사용
                                    => 경로에 들어있는 값 변수에 담기
                                    참고 : rest/memoController
                                    ex. remove 단 => @DeleteMapping("/remove/{mno}")
                                        매개변수 => @PathVariable Long mno
                                            => 주소줄 : http://localhost:8080/memo/remove/3
                            - 객체
                                1) ResponseEntity<T> : 데이터만 내보내기
                                    => data + 상태코드
                        
                        - 에러
                            1) CORS (Cross Origin Resource Sharing)
                                => 요청 서버 (localhost:8080)
                                => 응답 클라이언트 : localhost:5050
                                    => 요청과 응답의 서버가 다르면 막는 에러
                                
                                - 해결
                                    참고 : rest/config/CustomServletConfig
                                    => 서버단에서 해결함

                                    @Configuration
                                    public class CustomServletConfig implements WebMvcConfigurer {
                                        @Override
                                        public void addCorsMappings(CorsRegistry registry) {
                                            registry.addMapping("/**") => 어느곳에서 오든지 간에
                                                    .allowedOrigins("*") => 오픈하겠다
                                                    .allowedMethods("HEAD", "GET", "POST", "PUT", "DELETE")
                                                    .maxAge(300)
                                                    .allowedHeaders("Authorization", "Cache-Control", "Content-Type");
                                        }
                                    }
                    - Rest + 일반 컨트롤러
                        => 일반 컨트롤러에 @ResponseBody or ResponseEntity

        4) 내장 서버 : Tomcat(원래는 설치 후 사용 - 스프링부트를 사용한다면 내장되어 있음)
            => htttp://localhost:8080/ => Tomcat 서버 구동시, 기본 경로

            * SW(SoftWare)web 서버 : 브라우저를 통해 http, https 프로토콜에 응답하는 서버
                1. Apache
                2. NginX
                => but. java 는 위의 엔진으로만 구동되지 않음 why? java의 코드를 해석가능한 서버여야 함
                    => 해결 : WAS(Web Application Server) : 웹서버 + 자바해석 = Tomcat

        5) 에러
            200번대 : 정상
            400번대
                1. 404 : 주소 not found => 컨트롤러 경로 확인
                2. 405 : 허용되지 않은 메서드를 사용하려고 시도한 경우 => 컨트롤러 경로 + 매핑방식 확인
                3. 403 : 해당 페이지에 접근할 수 있는 권한이 없음
            500번대 : 서버쪽 에러
                => (서버) 터미널 확인 : TemplateInputException
            js 수정 : 브라우저 콘솔 확인

            * 매핑 방식

            - 에러의 해결
                1. exception 확인
                2. caused by 확인
        
        
        6) 사용자의 입력값 가져오기
            참고 : member/login, MemberController

            1. 변수 이용 : 타입 지정 가능, 변수명은 form 요소의 name 과 일치시키기
                => html 태그 안에서 사용
                => Model 의 addAttribute 와 함께 사용
                    1-1. th:text="${}" : thymeleaf 엔진을 활용한 자바를 사용하기
                        => 변수로 받아오면 html 화면단에서 값이 유지되지 않아서 찍을 수가 없음
                    1-2. th:value="${}"

                - Model 객체 : 해당 templates 로 같이 값을 가지고 가는 것
                    => 자바코드를 화면단에 함께 사용하는 방법 : thymeleaf 엔진 사용
                    
                    - 메서드
                        1. addAttribute("name", value);
                            => name : 화면단에서 불러서 사용 (중복 금지)

            2. 커맨드(DTO 사용) 객체 이용 : 타입 지정 가능, 변수명은 form 요소의 name 과 일치시키기
                => 장점 : template 페이지까지 입력값이 유지됨
                    입력값 유지 : input:hidden => value 값 넣어주기 if. value 값이 DTO 의 값이면 th:value 형식으로 넣기
                => 생성 규칙
                    ex. [[${command객체명?.변수명}]]
                    command 객체명 : 첫 문자만 소문자로 변환 (변수명을 사용한게 아님!, 객체명을 사용한거임!)
                    ? : 값이 null 일 수도 있다는걸 알려주는 문자
                    
            3. HttpServletRequest 이용 : 사용자의 정보 및 서버 쪽 정보 추출
                => spring 사용을 안할시, 가져오는 방법

        7) @ModelAttribute("별칭명")
            => 커맨드 객체에 별칭을 달아서 원래의 변수명이 아닌 별칭명으로 사용
                ex) model.addAttribute("num1", num1) == @ModelAttribute("num1")
                    => template 페이지에서 값을 유지하고 싶은 경우 사용

        8) RedirectAttributes : 컨트롤러에서 움직이는 방식이 redirect(리턴값이) 일 때 사용
            => 움직이면서 특정 값을 가지고 가고 싶을 때 사용

            * return 값에 redirect :/ => 다시 주소를 요청하는 것
                => 위의 방식으로 가면서 값을 보내는 방법
                => 이동이 없는 원주소로 가는 방식 : foward 방식

                - 메서드
                    1) addAttribute
                        => ex) rttr.addAttribute("userid", "10"); => ?userid=10 (주소줄에 따라감)
                            => 템플릿 사용법 : ${param.userid}
                    2) addFlashAttribute
                        => ex) rttr.addFlashAttribute("password", "12"); => session 객체에 담는 것과 같은 방식
                            => 템플릿 사용법 : ${password}

        9) 데이터 유지하기
            
            1. login.html 입력값 ==> 컨트롤러 ==> 다른 페이지에서 입력값 소멸?
                => 컨트롤러에서 변수로 직접 받아오는 방식 이용
                    ex. post (String name, int name ...) {}

            2. login.html 입력값 ==> 컨트롤러 ==> logout.html 까지 입력값 유지하고 싶다면?
                => forward 방식 or redirect 방식 이용

                    - forward 방식
                        1. @ModelAttribute
                        2. Model 객체
                        3. 커맨드 객체
                    - redirect 방식
                        1. RedirectAttributes 객체

            3. login.html 입력값 ==> 컨트롤러 ==> 모든 페이지에서 입력값 유지하고 싶다면?
                => 세션 이용 : 값을 서버쪽에 저장함 (객체 형태로 담는 것 가능)

                    - session
                        => HttpSession 객체를 이용해 저장
                            => 필요 없는 경우 : 제거 or 현재 세션이 유지되고 있는 브라우저 닫으면 종료됨

                    - 쿠키
                        => 값을 클라이언트 브라우저로 전송 후 저장함

        10) thymeleaf
            참고 : sample.html

            * JS 에서도 [[${name}]] 함수 사용이 가능
                ex) const name = "[[${name}]]";

            1. th:text="${name}"

            2. th:value="${name}"

            3. th:each="dto : ${listName}" th:text="${name}"
                => 리스트 함수를 하나씩 뿌리는 코드

               th:each="dto, 변수명 : ${listName}" th:text="${name}"
                => 변수명을 선언하여 추가적인 정보 추출 가능
                    ex. 변수명.index...
                    1. index : 번호
                    2. count : 개수
                    3. size : 리스트 크기
                    4. odd/even
                        => 홀/짝에 따라 true, false 반환
                        * odd : 홀수 / even : 짝수

            4. th:if="{조건}"
               th:unless="(조건)" => if-else 의 else 에 해당

            5. th:switch="${조건}" => switch-case 와 동일
                th:case="경우1"
                th:case="경우2"

            6. th:href="@{/경로}"
                => 사용의 이유 : 서버에 배포함에 따라 경로가 달라질 수 있기 때문에 사용
                
                * 배포 : 실제 서버에 프로그램을 올리는 작업
                    http://localhost:8080/ => 로컬
                    => http://도메인주소/app/member/login
                        => 만들어놓은 주소와 달리 서버에 배포함에 따라 주소의 경로가 흔들릴 수 있음!
                
                - a 태그와 비교
                    - 공통점
                        th:href 나 href 의 경로는 똑같음
                    - 차이점
                        파라메터를 보내는 방법이 다름
                            href : /member/login?id=hong
                            th:href : /member/login(id='hong')
            
            7. data-id : 전역속성
                * th:attr="data-id=${dto.id}"
                    => thymeleaf 에서 data-* 사용하는 법

            - 유틸리티 객체
                thymeleaf 홈페이지의 docs 의 19번 유틸리티 부분 참고

                1. #temporals.format(regDateTime, 'yyyy-MM-dd:MM')
                    => 시간을 깔끔하게 정리해주는 객체
                    => LocalDateTime 일 떄 사용
                2. #dates.format(name, 'yyyy-MM-dd')
                3. #numbers.formatInteger(name, 숫자, 'COMMA')
                4. #lists.size(name)
                4. #lists.contains(name, '찾으려는 것')

            - fragment (상속의 개념)
                * :: => 파일 내부의 이름이 무엇인지 의미
                참고 : fragment, layout, content
                    => 파일이 많으니 모든 파일을 통해서 확인
                th:fragment="name"
                    => 중복이 되는 영역을 조각내서 별도의 html 을 만들고 name 을 맞춘다

                - th: insert vs. replace
                    => insert
                        => 잡아논 태그 안에 삽입
                    => replace
                        => 잡아논 태그자체를 대체

    - 메서드
        1) 매핑의 방식

            * input 의 방식은 String 이지만 원하는 형식으로 자동 형변환을 통해서 받아올 수 있음
            * html 의 name 과 java 매핑의 변수명을 맞춰서 사용!
            * @GetMapping() 에서 받은 값들은 동일한 경로의 @PostMapping 에서도 그대로 유지가 됨

            1. @GetMapping()
                => method 가 get 인 방식끼리 연결
            2. @PostMapping()
                => method 가 post 인 방식끼리 연결
                => 서버로 전송
            * ({"경로 1", "경로 2"}) 경로를 두개 받을수도 있음

    - DTO(Data Trasfer Object)
        => 객체간 데이터 교환방식 (박스의 개념)

        - 생성 어노테이션
            @ToString
            @Builder
            @AllArgsConstructor
            @NoArgsConstructor
            @Setter
            @Getter

        
        - 페이지 DTO 만들기
            참고 : book

            - 생성 어노테이션
                - 요청하는 DTO
                    @NoArgsConstructor
                    @AllArgsConstructor
                    @Data
                    @SuperBuilder

                    - 선택에 따른 추가 생성 어노테이션
                        @SuperBuilder : 상속관계가 있을시, 부모의 것까지 사용가능
                            => 상속관계에서도 안전하게 사용
                            => 서브 클래스가 이 클래스를 상속할 때, 부모필드도 함께 빌더로 생성 가능
                    
                    - 클래스 내 생성 어노테이션
                        @Builder.Default : 빌더로 객체를 생성할 때, 필드가 포함 안되는 경우 사용할 기본값 지정
                            => ex) PageRequestDTO.builder().build() 만 생성 => page = 1, size = 10
                                => 참고 : book/PageRequestDTO
                        @Builder : 클래스 위에 쓰지않고 생성자에 쓰는 경우 => 딱 그 생성자만 만들어서 쓸거라는 것
                            => @Builder(builderMethodName = "withAll") : 이 생성자의 빌더 이름을 정해줌

                - 결과받는 DTO
                    @Data

    - 경로 설정
        http://localhost:8080/ => 고정

        - href 경로 설정시 현재경로(주소줄에 있는 경로)
            현재 경로 : http://localhost:8080/sample
            움직일 경로 : http://localhost:8080/ex1

            - "/" 의 차이
                th:href="@{ex2(id=${dto.id})}" : 현재경로에서 맨 마지막의 경로의 주소를 대체 설정 
                th:href="@{/ex2(id=${dto.id})}" : http://localhost:8080/ 다음부터 경로 설정
    
    - layout 구성
        참고 : jpa/layout
        => 각 구성에 맞게 들어갈 영역들을 알맞게 구성
            if 유동적인 영역일시 => th:block 태그로 영역을 잡기
    
    - service
        참고 : service
        => 컨트롤러가 service 메서드를 호출
            => service가 Repository 메서드를 호출 : 결과만 받아내는 곳

        - 어노테이션
            @RequiredArgsConstructor
                => + final 변수와 같이 사용 == @Autowired 에 final 안붙인거
                => 생성자가 자동으로 만들어지고 초기화 코드가 들어있음

            @Service
    
    - FK (외래키)
        참고 : team, sports
        => 외래키 제약 조건은 N쪽에 건다 why? 중복이 덜 되니까

            - 메서드
                @JoinColumn(name = "") : 외래키 필드명 지정
                    => 작성 안할시, 테이블명_PK명 으로 이름 생성
                @ToString(exclude = "컬럼명") : 순환참조에 에러가 나기 때문에 걸러야함
                @Builder.Default : OneToMany 의 빌더가 안되기에 붙여줌

            - 관계표현 (관계설정 어노테이션)
                * 끝자리가 One 인 것 : EAGER 상태

                @ManyToOne : 다대일
                    => left join 이 기본값
                    => 정보를 가지고 나올 때 관련있는 테이블 정보를 가지고 나옴
                    => FetchType.EAGER 인 상태
                    ex) 부서와 사원, 팀과 회원, 학과와 학생 등...

                @OneToMany : 일대다 => 양방향 연관관계
                    => One 에 해당하는 Table 만 select 실행이 기본값
                    => 정보를 가지고 나올 때 관련있는 테이블 정보를 안 가지고 나옴
                    => FetchType.LAZY 인 상태
                    * 양방향 연관관계 => 단방향 2개 넣은 것 (양방향은 관계는 없음)
                        => 부모에서 자식의 값을 조회하기 위해서 사용
                        => DB 테이블은 외래키 하나로 양쪽이 서로 조인 가능 => 객체는 한쪽만 관계 설정을 하면 안됨
                            => 단반향 2개를 여는 대신, 주가 되는 관계가 누구인지 지정 : N 쪽이 주
                                => @OneToMany(mappedBy = "N쪽의컬럼명")
                                    - 장점
                                        조회 방법이 하나 더 생기는 것 => 조회만 가능 나머지 권한 X
                                            ex) 부서 조회시, 부서에 속한 모든 사원 정보 조회
                        
                    - FetchType.LAZY 일 때 관련있는 테이블 정보에 접근시
                        => Lazy 관련 Exception 발생 : 정보를 가지고 나오지 않았다는 뜻
                            => 해결법
                                1. @Transactional : SELECT 구문 2개로 처리 (left join 처리)
                                    => 주가 되는 관계가 누구인지 지정
                                    => 두개의 테이블 접근을 한꺼번에 처리하는 방식

                                    - SELECT 구문 2개로 처리 => 조인 구문으로 처리
                                        1. 쿼리메서드 작성
                                        2. @EntityGraph 어노테이션 선언
                                            => LEFT JOIN을 걸어서 가지고 나오게 하는 방법
                                            - 사용법
                                                @EntityGraph(attributePaths = { "해당변수명" }, type = EntityGraphType.LOAD)
                                                    => attributePaths : 조인으로 처리할 대상
                                                    => type = EntityGraphType.LOAD : 로드 할 때

                                2. FetchType 변경
                                    => @OneToMany(fetch = FetchType.EAGER)
                                        * EAGER : 즉시의 의미
                                        => 관계가 있는 테이블의 정보를 즉시 가지고 나오기의 의미
                                        => left join 처리
                
                @OneToOne
                    => left join 이 기본값
                    => 정보를 가지고 나올 때 관련있는 테이블 정보를 가지고 나옴
                    => FetchType.EAGER 인 상태

                @ManyToMany
                    => 실제 업무 환경에서는 잘 사용되지 않음
                    => @ManyToOne 관계로 변경 후 사용
                    => FetchType.LAZY 인 상태
                    ex) 좋아요, 카테고리 등...
                    => 추가적인 확장성이 떨어짐
                        - 작성 ex.
                            @Builder.Default
                            @JoinTable(name = "CATEGORY_ITEM1", joinColumns = @JoinColumn(name = "CATEGORY_ID"), inverseJoinColumns = @JoinColumn(name = "ITEM_ID"))
                            @ManyToMany
                            private List<Item> items = new ArrayList<>();

            - 프록시
                => 지연 로딩 : 프록시를 통해 연관된 객체를 실제 사용하는 시점에 데이터베이스에서 조회하도록 함
                => 즉시 로딩 : 자주 함께 사용하는 객체들은 조인을 통해서 함께 조회
                
                - FetchType
                    * 모든 로딩은 지연 로딩이 default, 필요한 경우만 즉시 로딩
                    1. FetchType.LAZY : 지연 로딩
                    2. FetchType.EAGER : 즉시 로딩
                        2-1. @ManyToOne
                        2-2. @OneToOne
                            => FetchType.EAGER => FetchType.LAZY 바꾸기
    
    - 영속성 관리
        참고 : cascade
        => 양방향일 때 사용할 수 있는 개념
        => 부모 저장시, 자식 엔티티도 같이 저장
        => 영속성 상태에 있어야 Entity 삽입, 삭제, 수정 가능
        * cascade : 부모가 무슨일이 생길때 자식들도 같이 생기게 해줘
            => 영속성 전이라고 함
        
        => ManyToOne <> OneToMany 관계
            - 어노테이션
                => @OneToMany()
                    1. (cascade = { CascadeType.PERSIST })
                        => 별도의 자식repository에 저장하지 않고도 부모를 저장하면서 자식도 같이 저장
                        * 새로 만드는 것과 수정해야 하는 것을 동시에 수행하면 null 값을 넣을수 없다는 에러 발생할 수 있음
                    2. (cascade = { CascadeType.REMOVE })
                        => 부모 삭제시, 자식도 같이 삭제
                    3. (orphanRemoval = true)
                        => 부모 객체에서 자식 객체를 제거(고아객체)하면서 자식객체가 제거
                    4. (cascade = { CascadeType.MERGE })
                        => 수정의 개념
    - Pageable : 페이지 나누기
        참고 : board/SearchRepositoryImpl
        * 인포트 위치 : org.springframework.data.domain
        Pageable pageable = PageRequest.of(pageNumber, pageSize, Sort.by("컬럼명").descending()); => 선언 해야함
            => pageNumber : 몇페이지를 가지고 나오는지
            => pageSize : 한페이지에 몇개의 결과를 조회할 건지
            => descending : 내림차순
            => 단, querydsl 사용시, sort 불가!

    - Repository 에 원하는 메서드 만들기
        참고 : todo/ToDoRepository, jpa/BoardRepository, jpa/ItemRepository
                relation/team => 조인과 관련된 심화 참고

        - 방법
            1) 쿼리 메서드
                참고 : jpa/BoardRepository
                    => 사이트 : https://docs.spring.io/spring-data/jpa/reference/jpa/query-methods.html
                => 규칙이 존재함 : 메서드 명을 만드는 규칙
                => 첫 시작은 List<Entity명>
                1. findBy컬럼명 == where 컬럼명 = ?

                2. findBy컬럼명StartingWith == 컬럼명 like '?%'
                findBy컬럼명EndingWith == 컬럼명 like '%?'
                findBy컬럼명ContainingWith == 컬럼명 like '%?%'

                3. findBy컬럼명ContainingOr컬럼명Containing == 컬럼명1 like '%?1%' or 컬럼명2 like '%?2%'
                findBy컬럼명ContainingAnd컬럼명Containing == 컬럼명1 like '%?1%' and 컬럼명2 like '%?2%'

                4. findBy컬럼명GreaterThan == 컬럼명 > ?

                5. findBy컬럼명Between == where 컬럼명 between ? and ?

                * 쿼리에 붙이는 추가 메서드
                    1. + OrderBy컬럼명Desc : 컬럼명에 따른 내림차순
                       + OrderBy컬럼명Asec

            2) 쿼리 어노테이션 : 훨씬 유용함
                => 규칙이 존재하지 않음 : 메서드명의 이름은 마음대로 가능
                => DB의 쿼리문과 유사함
                => 첫 시작은 List<Entity명>
                    => 전체적인 조회는 Entity 형식으로 가져오지만 개별적으로 몇개만의 조회는 Object 형식으로 가져옴
                        ex. @Query("select b from Board b where b.writer like %?1%")
                            => Entity : List<Entity명>
                        ex. @Query("select b.title, b.writer from Board b where b.title like ?1%")
                            => Object 배열 : List<Object[]>

                * 기본 규칙
                    1. 컬럼명 : 클래스명(첫글자 대문자) => entity 이름 기준
                    2. ?1 => ?의 순서
                        => 파라메터 설정
                            1. ?1
                            2. :필드명(변수명)
                        * @Param("컬럼명") : 정확하게 넘어오는 요소를 어떤 변수에 집어넣는지 알려줄 수 있음
                    3. @Modifying : Delete, Update 시에는 무조건 사용
                        => 만든 쿼리메서드 위에 붙여서 작성

                - 어노테이션
                    1. findBy컬럼명
                        == @Query("select * from 클래스명 b where b.컬럼명 = ?1")
                            
                    2. findBy컬럼명StartingWith
                        == @Query("select b from 클래스명 b where b.컬럼명 like ?1%")

                * 어노테이션을 활용한 일반적인 쿼리문 만들기
                    => Entity 명이 아닌 sql 구문 처럼 DB단의 테이블명 이용
                    => 사용을 잘 하지 않음
                        방법 1)
                            @Query(value = "select * from 테이블명 b where b.컬럼명 > ?1", nativeQuery = true)
                        방법 2)
                            @NativeQuery("select * from 테이블명 b where b.컬럼명 > ?1")

                * 관계가 형성된 테이블의 쿼리문
                    참고 : relation/TeamMemberRepository
                    * DB 단의 ON 은 알아서 처리해 줌 (PK 기준으로)

            3) QueryDSL 이용 : 다른 라이브러리의 도움을 받기
                참고 : jpa/ItemRepository, jpa/BoardRepository, MemberRepository
                => Q 파일을 사용 (Iterable 로 반환하는 값들이 dsl 임)
                - MavenRepository 접속 => querydsl 검색 => JPA Support 와 APT Support 가져오기 (porm.xml)
                    => plugin 에 추가적인 작성
                
                - 이용방법
                    1) QuerydslPredicateExecutor : 인터페이스
                        참고 : book/repository (테이블 1개)
                        => <Entity명> 를 extends 로 상속
                        => 간단한 곳에서 사용 편리함
                        => 조인이 불가능(left join 불가능)
                        => 복잡한 실무 환경에서는 사용하기에 한계가 명확
                        => Q파일명 name = Q파일명.name;
                        => 객체 생성이 Q파일에 있음 (new)
                    
                        - 메서드
                            1) eq("조건") : =
                            2) startsWith("조건") : 조건%
                            3) endsWith("조건") : %조건
                            4) contains("조건") : %조건%
                            5) gt("조건") : > 조건
                            6) goe("조건") : >= 조건

                        * BooleanBuilder : 조건
                            - 사용법 ex) where itemNm = 'item2' and price > 1000
                                builder.and(item.itemNm.eq("item2"));
                                builder.and(item.price.gt(1000));
                                itemRepository.findAll(builder);

                        - 별도 메서드 (QuerydslPredicateExecutor 만 가능)
                            Sort.by("컬럼명") : 컬럼명을 기준으로 정렬
                                => 1. ascending() : 오름차순
                                => 2. descending() : 내림차순

                    2) QuerydslRepositorySupport : 추상클래스
                        참고 : mart/QueryDslOrderRepositoryImpl, board/QueryDslOrderRepositoryImpl (테이블 3개)
                            => 다시 복습 필요
                        => 확장성 제공
                        => 조인 가능 (중요!!!!!!!!!!!!!!!!!!!!!!!)
                        => FROM 절에서 뽑아내지 못하고 SELECT 절에서 밖에 뽑을 수가 없음
                        => select 절 두개를 뽑으면 무조건 List 안에 Object[]로 받아야 함
                        => Sort 객체의 사용이 불가 => Sort 직접 제작

                        - 메서드
                            1) fetch() : 리스트 조회, 데이터 없는 경우 빈리스트 반환
                            2) fetchFirst() : limit(1), fect one()
                            3) fetchOne() : 결과가 없으면 null, 둘 이상이면 NonUniqueException
                            4) fetchResults() : 페이징 정보 포함, total count 쿼리 추가 실행
                            5) fetchCount() : count 쿼리로 변경해서 count 수 조회
                                => 전체 개수 조회

                        - 필요 구문
                            1) JPQLQuery<E> : query문 작성을 위한 객체
                            2) JPAExpressions : 서브쿼리문 작성을 위한 시작 객체
                            3) Tuple : 쿼리문의 결과값의 행 하나를 담는 객체
                                => List<Tuple> 로 가져가지 않고 stream.map() 을 통해서 List<Object[]> 로 변환해서 반환함
                                    => 단 해당 객체는 Pageable 을 사용할 수가 없음
                        
                        - Sort 재정의
                            참고 : board/SearchBoardRepository
                    
    - 전체적인 웹과 DB와 백의 동작의 순서
        1. 서버주소 요청 => 컨트롤러 응답 => 서비스 => repository
        2. repository 리턴 => 서비스 리턴 => 컨트롤러 리턴값 받기